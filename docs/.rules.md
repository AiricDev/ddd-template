# AI辅助DDD软件工程模板：全局规则与指南

## 概述：AI辅助DDD开发的总体思路
本模板将领域驱动设计（DDD）的战略和战术模式与AI深度融合，演进传统软件工程实践到AI时代。DDD强调通过通用语言（Ubiquitous Language）、界限上下文（Bounded Contexts）和聚合（Aggregates）来管理复杂性；传统软件工程则依赖阶段化流程（如需求-设计-实现-测试-维护）和文档驱动开发。在AI时代，我们通过目录级规则机制（灵感来源于Claude Code的逐级prompt继承）让AI成为“阶段专家助手”：
- **AI角色**：处理重复任务（如生成草案、验证一致性），提供反馈循环；人类聚焦高层决策和澄清。
- **协作原则**：
  - **继承机制**：AI加载当前目录的ai_rules.md，并向上逐级合并父级规则（优先本地 > 阶段 > 全局）。
  - **思维适应**：每个阶段有特定“心智模式”（e.g., 探索 vs. 严谨），AI根据规则调整响应风格。
  - **人类-AI循环**：用户输入（e.g., 需求描述）-> AI生成草案 -> 用户反馈/澄清 -> AI迭代（最多3轮）。
  - **输出标准化**：使用Markdown（文档）、YAML（模型）或Gherkin（spec），确保可版本控制（Git）和自动化验证。
  - **验证与演进**：融入BDD（行为驱动开发）风格，确保输出符合DDD不变式（invariants）；变更历史通过Git和evolution/目录追踪。
- **益处与传统演进**：减少设计偏差（通过结构化prompt）和审查负担（人类只审抽象层/BDD spec）；AI自动化70-80%非代码工作，提升效率；适用于复杂系统，如企业级应用或AI驱动产品。
- **适用范围**：任何DDD项目；示例域：订单处理系统（Order Domain），包含聚合如OrderAggregate。

此文件作为全局system-prompt，所有子目录编辑线程必须包含它。人类开发者请阅读本指南理解目录体系；AI工具请解析规则定义部分生成响应。

## 目录结构定位与用法
项目根目录组织为5个阶段子目录，按DDD流程线性排列（从战略设计到战术实现和演进）。每个目录聚焦特定DDD活动，包含本地ai_rules.md（定义阶段规则）。用法：
- **创建文件**：在相应目录下新增文档（e.g., .md或.yaml），AI根据合并规则生成内容。
- **导航**：从1-discovery开始，逐步推进；跨阶段引用使用相对路径（e.g., [../2-modeling/aggregates/order_aggregate.yaml]）。
- **变更处理**：所有修改通过Git提交；在5-evolution/记录原因和历史（详见其规则）。

### 1-discovery/：需求收集与发现阶段
- **定位**：DDD战略设计起点，聚焦问题域分析、事件风暴（Event Storming）和界限上下文识别。目标：建立通用语言草案和上下文映射，避免子域混淆。
- **用法**：输入业务描述/PRD，AI生成事件列表、痛点分析和初步上下文图。思维方式：探索性，鼓励多样选项。
- **典型输出**：events_storm.md（事件列表）、context_mapping.yaml（界限上下文图）。
- **示例**：对于订单域，生成“事件：订单提交 [触发：用户下单]”。

### 2-modeling/：领域建模阶段
- **定位**：DDD战术设计核心，构建聚合、实体、值对象和不变式。强调高内聚、低耦合，确保模型反映业务本质。
- **用法**：输入发现阶段输出，AI生成模型草案，包括函数级细节（输入/输出参数、调用关系）。思维方式：严谨，注重不变式验证。
- **典型输出**：aggregates/order_aggregate.yaml（聚合定义，包括invariants）。
- **示例**：设计OrderAggregate的不变式：“订单状态转换必须合法（Pending -> Confirmed）”。

### 3-implementation/：实现与编码阶段
- **定位**：将模型转化为可执行代码，融入架构分层（e.g., Clean Architecture）和集成模式（如事件驱动）。
- **用法**：输入模型草案，AI生成代码框架和BDD spec。思维方式：实践，聚焦可实现性和幂等性。
- **典型输出**：src/order_service.py（代码）、bdd_specs/order_workflow.feature（Gherkin spec）。
- **示例**：基于聚合生成“函数：submitOrder(input: OrderRequest, output: OrderId)”。

### 4-testing/：测试与验证阶段
- **定位**：确保模型和实现符合DDD原则，通过单元/集成测试验证边界和不变式。
- **用法**：输入实现输出，AI生成测试用例和覆盖报告。思维方式：批判，覆盖边缘案例。
- **典型输出**：unit_tests/order_aggregate_test.md（测试脚本）。
- **示例**：测试“订单聚合在并发修改下的不变式”。

### 5-evolution/：演进与维护阶段
- **定位**：处理软件持续迭代，追踪变更历史、优化和重构。支持DDD的演进式设计（e.g., 上下文重绘）。
- **用法**：输入新需求/日志，AI生成变更日志、影响分析和优化报告。思维方式：反思，数据驱动。
- **典型输出**：changes/2025-08-11-v1.1/change_log.md（变更记录，包括引用和原因）。
- **示例**：分析“添加多租户支持”的影响，引用并diff原有聚合模型。

## 全局规则定义（JSON-like，供AI解析）
{
  "template_version": "1.0",
  "global_mindset": "DDD一致性优先：所有输出必须使用通用语言，确保界限上下文纯净",
  "collaboration_flow": [
    "Step1: 解析用户输入和继承规则",
    "Step2: 生成草案（符合output_format）",
    "Step3: 提问1-3个澄清点（如果不确定）",
    "Step4: 基于反馈迭代"
  ],
  "constraints": [
    "输出必须可验证（e.g., 包含不变式检查）",
    "引用DDD原则（e.g., Aggregates for transaction boundaries）",
    "避免项目特定术语；使用抽象示例"
  ],
  "prompt_template": "基于{stage}规则和{user_input}，生成{output_type}，确保与DDD全局思路对齐。",
  "output_format_defaults": {
    "document": "Markdown with sections",
    "model": "YAML with properties, methods, invariants",
    "spec": "Gherkin (Given-When-Then)"
  },
  "validation_rules": "检查输出是否高内聚、低耦合；如果违反，建议修正"
}

## 示例全局提示使用
- **人类输入**： "在discovery阶段，分析订单域的需求。"
- **AI响应**：加载此文件 + 1-discovery/ai_rules.md，生成事件列表草案，并提问"订单域的子域边界是什么？"。

## 维护与扩展
- **版本控制**：将整个目录置于Git仓库，规则变更通过PR审查。
- **自定义**：项目可添加本地规则覆盖全局（e.g., 特定域的通用语言）。
- **工具集成**：使用VS Code插件自动加载规则；如果AI不确定，输出"请澄清{point}"。
- **反馈**：如果规则不适配，迭代此文件，作为模板演进。

此模板旨在桥接传统DDD与AI协作。如果您是AI，严格遵守规则；如果您是人类，欢迎fork并贡献！
