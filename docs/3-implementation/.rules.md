# AI辅助DDD软件工程模板：Implementation阶段规则

## 阶段概述与定位
此目录对应DDD的实现阶段：将领域模型转化为可执行代码（Implementation Phase）。焦点是基于modeling输出，生成代码框架、集成模式（如事件驱动）和BDD spec，确保实现纯净、高内聚。这演进传统软件工程的“编码与集成”实践，在AI时代通过自动化生成减少bug，同时严格遵守Clean Architecture以维护DDD边界。

- **思维方式（Agent专用）**：实践、分层、职责导向。在生成任何代码前，必须进行chain-of-thought规划：判断每个组件的职责、所属层/模块、边界（e.g., '此逻辑属于Use Cases层，因为它封装业务规则'）。避免跨层耦合，确保Entities层独立于外部变化。
- **Agent行为模式**：直接执行编程任务：1. 分析输入并规划层分配；2. 生成代码；3. 自验证一致性。无人类引导循环——如果不确定，输出假设并标记为待审；严格约束：所有代码必须分层，实现DDD不变式。
- **协作原则（继承全局，调整为AI自治）**：AI基于输入直接生成，无迭代提问；输出包括预规划步骤，确保可追溯。
- **参考输入**：上游modeling文档（e.g., 聚合YAML，相对路径：../2-modeling/aggregates/order_aggregate.yaml）；discovery事件。
- **产出文档类型**：代码文件（e.g., .py）、BDD spec（.feature）。这些文档服务于测试阶段：提供可执行基础。
- **目标服务**：忠实实现DDD模型，维护Clean Architecture独立性；输出应可部署（e.g., 通过依赖注入）。

人类开发者：使用此目录触发AI生成代码，提供上游输入；审阅输出以验证。AI工具：严格遵守规则，直接执行任务，确保分层严谨。

## 目录用法指南
- **文件创建**：新增代码或spec文件（e.g., src/order_service.py），AI根据规则填充内容。
- **子目录建议**：可添加src/（代码）、bdd_specs/（规范），继承本规则以细化（e.g., src/ai_rules.md强调语言特定约束）。
- **跨阶段引用**：输出可链接到testing/（e.g., [../4-testing/unit_tests/]），但本阶段聚焦实现。
- **验证**：代码必须通过层边界检查；如果违反，AI自拒并建议重构。

## 阶段规则定义（JSON-like，供AI解析，继承全局）
{
  "phase": "implementation",
  "inherited_from": "全局规则（合并constraints、output_format_defaults）",
  "mindset": "分层实践：始终判断职责（Entities: 核心模型；Use Cases: 业务逻辑；Adapters: 集成；Frameworks: 外部）。先规划，后编码",
  "agent_behavior": {
    "execution_mode": "自治编程：无人类引导；输出结构：1. 层分配计划；2. 生成代码；3. 自验证报告",
    "pre_coding_step": "Chain-of-thought：为每个组件指定层/模块（e.g., 'submitOrder属于Use Cases，因为它协调Entities'），识别边界（e.g., 无直接DB访问）",
    "constraints": [
      "严格Clean Architecture：Entities独立；Use Cases无外部依赖；Adapters处理IO",
      "DDD契合：实现聚合边界、不变式（e.g., 通过guard clauses）；使用事件驱动解耦",
      "幂等与边界：代码必须处理重试、异常"
    ],
    "response_style": "精确、可执行：包括注释解释层归属；语言默认Python（可指定）"
  },
  "prompt_template": "基于{user_input}和参考{input_docs}，执行编程：先规划层分配，然后生成{output_type}，严格遵守Clean Architecture和DDD。",
  "reference_inputs": [
    "Modeling输出（e.g., 聚合YAML）",
    "Discovery事件/上下文"
  ],
  "output_formats": {
    "code_file": "Python类/函数：# Layer: Use Cases\nclass OrderUseCase: ...",
    "bdd_spec": "Gherkin：Feature: Order Submission\nScenario: ..."
  },
  "goals_served": [
    "将DDD模型转化为分层代码，确保设计一致性",
    "服务测试与演进：提供可注入、可扩展实现"
  ],
  "validation_rules": "自检查：层边界无违反（e.g., Entities无IO）；不变式实现完整；如果失败，输出'无效生成：{reason}'并停止"
}

## 示例Agent执行输出
- **人类输入**： "基于OrderAggregate YAML，实现submitOrder功能。"
- **AI响应（直接生成）**：
  1. **层分配计划**：
     - Entities层：OrderEntity（核心模型，不变式检查）。
     - Use Cases层：OrderSubmissionUseCase（业务逻辑，协调提交）。
     - Adapters层：OrderRepositoryAdapter（持久化接口）。
     - 无Frameworks（假设无外部UI）。
     - 职责边界：Use Cases调用Entities，不直接访问DB。
  2. **生成代码**（e.g., order_use_case.py）：
     ```
     # Layer: Entities (DDD Aggregate)
     class OrderEntity:
         def __init__(self, id, status):
             self.id = id
             self.status = status
             # Invariant: status must be valid
             if status not in ['Pending', 'Confirmed']:
                 raise ValueError("Invalid status")

     # Layer: Use Cases (DDD Domain Service)
     class OrderSubmissionUseCase:
         def __init__(self, repository):  # Dependency Injection
             self.repository = repository

         def submit(self, order_request):
             order = OrderEntity(order_request.id, 'Pending')
             # Business logic: apply invariants
             self.repository.save(order)
             return order.id  # Output: OrderId
     ```
  3. **自验证报告**： "符合Clean Architecture：Entities独立；Use Cases封装逻辑；边界无违反。不变式通过guard实现。"

## 维护与扩展提示
- **继承全局**：如果冲突，本地规则优先（e.g., 覆盖validation以添加语言检查）。
- **AI自我检查**：输出末尾添加"此实现严格分层？[是/否，为什么]"。
- **人类提示**：如果需要调整，输入"重新生成 with {change}"；审阅重点：层计划准确性。
- **子目录扩展**：为src/添加规则，聚焦特定层（e.g., 强调Adapters的反腐层）。

此规则确保AI自治生成符合DDD/Clean Architecture的代码。如果您是AI，启动执行模式；如果您是人类，准备输入以触发生成！
